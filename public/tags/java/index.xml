<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Trung Hau Blog</title><link>http://localhost:1313/tags/java/</link><description>Recent content in Java on Trung Hau Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 27 Dec 2025 18:00:00 +0700</lastBuildDate><atom:link href="http://localhost:1313/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Kiến trúc JVM và Cơ chế quản lý bộ nhớ chuyên sâu trong Java</title><link>http://localhost:1313/blog/jvm-archirecture/</link><pubDate>Sat, 27 Dec 2025 18:00:00 +0700</pubDate><guid>http://localhost:1313/blog/jvm-archirecture/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/jvm-architecture.png" alt="Kiến trúc JVM"&gt;&lt;/p&gt;
&lt;h2 id="1-giới-thiệu-về-máy-ảo-java-jvm"&gt;1. Giới thiệu về máy ảo Java (JVM)&lt;/h2&gt;
&lt;p&gt;JVM (Java Virtual Machine) là trái tim của nền tảng Java, đóng vai trò trung gian giữa chương trình Java và hệ điều hành. Chính JVM là yếu tố giúp Java thực hiện được khẩu hiệu nổi tiếng: &lt;strong&gt;“Write Once, Run Anywhere”&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Thay vì biên dịch trực tiếp sang mã máy của từng hệ điều hành như C/C++, Java được biên dịch thành &lt;strong&gt;Bytecode (.class)&lt;/strong&gt;. Bytecode này không phụ thuộc nền tảng, và JVM trên từng hệ điều hành sẽ chịu trách nhiệm:&lt;/p&gt;</description></item><item><title>Lập trình hướng đối tượng nâng cao: Từ Abstract Class đến Interface</title><link>http://localhost:1313/blog/java-oop/</link><pubDate>Fri, 26 Dec 2025 14:30:00 +0700</pubDate><guid>http://localhost:1313/blog/java-oop/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-oop.png" alt="Sự khác biết giữa abstract và interface"&gt;&lt;/p&gt;
&lt;h2 id="1-bản-chất-của-tính-trừu-tượng-abstraction"&gt;1. Bản chất của tính Trừu tượng (Abstraction)&lt;/h2&gt;
&lt;p&gt;Tính trừu tượng (Abstraction) là một trong 4 trụ cột của lập trình hướng đối tượng (OOP), cho phép lập trình viên tập trung vào &lt;strong&gt;cái gì&lt;/strong&gt; hệ thống làm được thay vì &lt;strong&gt;nó làm như thế nào&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Nói cách khác, trừu tượng giúp ẩn đi các chi tiết triển khai phức tạp và chỉ phơi bày những hành vi cần thiết cho bên sử dụng.&lt;/p&gt;</description></item><item><title>Phân tích hiệu năng các cấu trúc dữ liệu trong Java Collections</title><link>http://localhost:1313/blog/java-collections/</link><pubDate>Fri, 26 Dec 2025 16:45:00 +0700</pubDate><guid>http://localhost:1313/blog/java-collections/</guid><description>&lt;h2 id="1-tổng-quan-về-collections-framework"&gt;1. Tổng quan về Collections Framework&lt;/h2&gt;
&lt;p&gt;Java Collections Framework (JCF) là một tập hợp các interface, class và thuật toán giúp lập trình viên lưu trữ, truy xuất và thao tác dữ liệu dạng tập hợp (collection of objects).&lt;/p&gt;
&lt;p&gt;Trước khi có JCF, việc quản lý dữ liệu trong Java rất rời rạc. JCF ra đời nhằm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chuẩn hóa&lt;/strong&gt; cách làm việc với dữ liệu.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Giảm số lượng code&lt;/strong&gt; tự viết (reusable code).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tăng hiệu năng&lt;/strong&gt; thông qua các thuật toán đã được tối ưu.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="các-interface-cốt-lõi"&gt;Các interface cốt lõi:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List:&lt;/strong&gt; Dữ liệu có thứ tự, cho phép trùng lặp (ArrayList, LinkedList).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set:&lt;/strong&gt; Không cho phép trùng lặp (HashSet, TreeSet).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map:&lt;/strong&gt; Lưu trữ dữ liệu theo cặp Key–Value (HashMap, TreeMap).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-sự-khác-biệt-về-hiệu-năng-giữa-list"&gt;2. Sự khác biệt về hiệu năng giữa List&lt;/h2&gt;
&lt;p&gt;Việc chọn đúng loại List ảnh hưởng rất lớn đến tốc độ xử lý, đặc biệt với dữ liệu lớn.&lt;/p&gt;</description></item><item><title>Xử lý đa luồng và Concurrent Programming trong Java</title><link>http://localhost:1313/blog/java-threads/</link><pubDate>Fri, 26 Dec 2025 19:20:00 +0700</pubDate><guid>http://localhost:1313/blog/java-threads/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-threads.png" alt="Luồng trong java"&gt;&lt;/p&gt;
&lt;h2 id="1-thread-là-gì"&gt;1. Thread là gì?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Thread (Luồng)&lt;/strong&gt; là đơn vị nhỏ nhất của quá trình thực thi trong một ứng dụng. Một chương trình Java có thể chứa nhiều thread chạy song song, chia sẻ cùng bộ nhớ Heap nhưng có Stack riêng biệt.&lt;/p&gt;
&lt;p&gt;Đa luồng giúp ứng dụng phản hồi nhanh hơn, tận dụng tối đa CPU đa nhân và xử lý song song các tác vụ nặng như I/O hay Database.&lt;/p&gt;</description></item><item><title>Java 8+ Features: Làm chủ Stream API và Lambda Expression</title><link>http://localhost:1313/blog/java-8-streams/</link><pubDate>Fri, 26 Dec 2025 21:15:00 +0700</pubDate><guid>http://localhost:1313/blog/java-8-streams/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-8-streams.png" alt="Java 8 Streams"&gt;&lt;/p&gt;
&lt;h2 id="1-kỷ-nguyên-lập-trình-hàm-functional-programming"&gt;1. Kỷ nguyên lập trình hàm (Functional Programming)&lt;/h2&gt;
&lt;p&gt;Java 8 đánh dấu một bước ngoặt lớn khi giới thiệu các khái niệm &lt;strong&gt;Functional Programming&lt;/strong&gt; như Lambda Expression, Functional Interface, và Stream API. Lập trình hàm giúp mã nguồn ngắn gọn, giảm bớt các trạng thái (state) dư thừa và dễ bảo trì hơn so với mô hình OOP thuần túy trước đây.&lt;/p&gt;
&lt;h3 id="11-lambda-expression"&gt;1.1 Lambda Expression&lt;/h3&gt;
&lt;p&gt;Lambda Expression cho phép bạn truyền &lt;strong&gt;hành vi (behavior)&lt;/strong&gt; như một tham số, giúp loại bỏ các lớp ẩn danh (anonymous classes) dài dòng.&lt;/p&gt;</description></item></channel></rss>