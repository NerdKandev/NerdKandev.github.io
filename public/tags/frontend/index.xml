<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Frontend on Trung Hau Blog</title><link>http://localhost:1313/tags/frontend/</link><description>Recent content in Frontend on Trung Hau Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 26 Dec 2025 23:45:00 +0700</lastBuildDate><atom:link href="http://localhost:1313/tags/frontend/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript Event Loop – Hiểu đúng để làm chủ bất đồng bộ</title><link>http://localhost:1313/blog/js-event-loop/</link><pubDate>Fri, 26 Dec 2025 22:30:00 +0700</pubDate><guid>http://localhost:1313/blog/js-event-loop/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/js-event-loop.png" alt="Sự kiện vòng lặp trong Javascript"&gt;&lt;/p&gt;
&lt;h2 id="1-javascript-là-single-threaded-nhưng-không-hề-đơn-giản"&gt;1. JavaScript là Single-threaded, nhưng không hề đơn giản&lt;/h2&gt;
&lt;p&gt;JavaScript thường bị hiểu lầm là “chậm” vì chỉ chạy trên một luồng duy nhất. Thực tế, chính mô hình &lt;strong&gt;single-threaded&lt;/strong&gt; kết hợp với &lt;strong&gt;non-blocking I/O&lt;/strong&gt; đã giúp JavaScript trở thành nền tảng cốt lõi của web hiện đại.&lt;/p&gt;
&lt;p&gt;JavaScript chỉ có một &lt;strong&gt;Call Stack&lt;/strong&gt;, đồng nghĩa với việc tại một thời điểm, chỉ có một đoạn code được thực thi. Tuy nhiên, các tác vụ nặng như &lt;code&gt;setTimeout&lt;/code&gt;, HTTP request, hay File I/O sẽ được ủy quyền cho môi trường thực thi (Browser hoặc Node.js) xử lý.&lt;/p&gt;</description></item><item><title>Closure &amp; Prototype trong JavaScript – Nền tảng quyền lực nhưng dễ bị hiểu sai</title><link>http://localhost:1313/blog/js-closure-prototype/</link><pubDate>Fri, 26 Dec 2025 23:15:00 +0700</pubDate><guid>http://localhost:1313/blog/js-closure-prototype/</guid><description>&lt;h2 id="1-closure-là-gì"&gt;1. Closure là gì?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Closure&lt;/strong&gt; là khả năng của một hàm ghi nhớ và truy cập được các biến nằm ngoài phạm vi (scope) của nó, ngay cả khi hàm bên ngoài đã thực thi xong. Nói cách khác, một hàm luôn “đi kèm” với lexical scope nơi nó được khai báo.&lt;/p&gt;
&lt;h3 id="ví-dụ-cơ-bản"&gt;Ví dụ cơ bản:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;function&lt;/span&gt; &lt;span style="color:#1f2328"&gt;outer&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;let&lt;/span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt; &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#0550ae"&gt;0&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;return&lt;/span&gt; &lt;span style="color:#cf222e"&gt;function&lt;/span&gt; &lt;span style="color:#1f2328"&gt;inner&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt;&lt;span style="color:#0550ae"&gt;++&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;return&lt;/span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#1f2328"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;const&lt;/span&gt; &lt;span style="color:#1f2328"&gt;counter&lt;/span&gt; &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#1f2328"&gt;outer&lt;/span&gt;&lt;span style="color:#1f2328"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mặc dù outer() đã chạy xong, biến count vẫn tồn tại trong bộ nhớ vì inner() đang giữ tham chiếu đến nó. Đây chính là sức mạnh của Closure.&lt;/p&gt;</description></item><item><title>Tối ưu hiệu năng Frontend – DOM, Virtual DOM và Event Delegation</title><link>http://localhost:1313/blog/js-dom-performance/</link><pubDate>Fri, 26 Dec 2025 23:45:00 +0700</pubDate><guid>http://localhost:1313/blog/js-dom-performance/</guid><description>&lt;h2 id="1-dom-là-gì-và-tại-sao-nó-chậm"&gt;1. DOM là gì và tại sao nó chậm?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DOM (Document Object Model)&lt;/strong&gt; là cấu trúc dạng cây đại diện cho toàn bộ HTML của trang web. Trình duyệt sử dụng DOM để render giao diện, gắn CSS và lắng nghe sự kiện.&lt;/p&gt;
&lt;p&gt;Rất nhiều website chậm không phải vì logic phức tạp, mà vì &lt;strong&gt;thao tác với DOM sai cách&lt;/strong&gt;. Mỗi khi DOM thay đổi, trình duyệt phải thực hiện chuỗi tác vụ tốn kém:&lt;/p&gt;</description></item></channel></rss>