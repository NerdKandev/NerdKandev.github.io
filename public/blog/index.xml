<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog Kiến Thức Lập Trình on Trung Hau Blog</title><link>http://localhost:1313/blog/</link><description>Recent content in Blog Kiến Thức Lập Trình on Trung Hau Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 27 Dec 2025 18:00:00 +0700</lastBuildDate><atom:link href="http://localhost:1313/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Kiến trúc JVM và Cơ chế quản lý bộ nhớ chuyên sâu trong Java</title><link>http://localhost:1313/blog/jvm-archirecture/</link><pubDate>Sat, 27 Dec 2025 18:00:00 +0700</pubDate><guid>http://localhost:1313/blog/jvm-archirecture/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/jvm-architecture.png" alt="Kiến trúc JVM"&gt;&lt;/p&gt;
&lt;h2 id="1-giới-thiệu-về-máy-ảo-java-jvm"&gt;1. Giới thiệu về máy ảo Java (JVM)&lt;/h2&gt;
&lt;p&gt;JVM (Java Virtual Machine) là trái tim của nền tảng Java, đóng vai trò trung gian giữa chương trình Java và hệ điều hành. Chính JVM là yếu tố giúp Java thực hiện được khẩu hiệu nổi tiếng: &lt;strong&gt;“Write Once, Run Anywhere”&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Thay vì biên dịch trực tiếp sang mã máy của từng hệ điều hành như C/C++, Java được biên dịch thành &lt;strong&gt;Bytecode (.class)&lt;/strong&gt;. Bytecode này không phụ thuộc nền tảng, và JVM trên từng hệ điều hành sẽ chịu trách nhiệm:&lt;/p&gt;</description></item><item><title>Lập trình hướng đối tượng nâng cao: Từ Abstract Class đến Interface</title><link>http://localhost:1313/blog/java-oop/</link><pubDate>Fri, 26 Dec 2025 14:30:00 +0700</pubDate><guid>http://localhost:1313/blog/java-oop/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-oop.png" alt="Sự khác biết giữa abstract và interface"&gt;&lt;/p&gt;
&lt;h2 id="1-bản-chất-của-tính-trừu-tượng-abstraction"&gt;1. Bản chất của tính Trừu tượng (Abstraction)&lt;/h2&gt;
&lt;p&gt;Tính trừu tượng (Abstraction) là một trong 4 trụ cột của lập trình hướng đối tượng (OOP), cho phép lập trình viên tập trung vào &lt;strong&gt;cái gì&lt;/strong&gt; hệ thống làm được thay vì &lt;strong&gt;nó làm như thế nào&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Nói cách khác, trừu tượng giúp ẩn đi các chi tiết triển khai phức tạp và chỉ phơi bày những hành vi cần thiết cho bên sử dụng.&lt;/p&gt;</description></item><item><title>Phân tích hiệu năng các cấu trúc dữ liệu trong Java Collections</title><link>http://localhost:1313/blog/java-collections/</link><pubDate>Fri, 26 Dec 2025 16:45:00 +0700</pubDate><guid>http://localhost:1313/blog/java-collections/</guid><description>&lt;h2 id="1-tổng-quan-về-collections-framework"&gt;1. Tổng quan về Collections Framework&lt;/h2&gt;
&lt;p&gt;Java Collections Framework (JCF) là một tập hợp các interface, class và thuật toán giúp lập trình viên lưu trữ, truy xuất và thao tác dữ liệu dạng tập hợp (collection of objects).&lt;/p&gt;
&lt;p&gt;Trước khi có JCF, việc quản lý dữ liệu trong Java rất rời rạc. JCF ra đời nhằm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chuẩn hóa&lt;/strong&gt; cách làm việc với dữ liệu.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Giảm số lượng code&lt;/strong&gt; tự viết (reusable code).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tăng hiệu năng&lt;/strong&gt; thông qua các thuật toán đã được tối ưu.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="các-interface-cốt-lõi"&gt;Các interface cốt lõi:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List:&lt;/strong&gt; Dữ liệu có thứ tự, cho phép trùng lặp (ArrayList, LinkedList).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set:&lt;/strong&gt; Không cho phép trùng lặp (HashSet, TreeSet).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map:&lt;/strong&gt; Lưu trữ dữ liệu theo cặp Key–Value (HashMap, TreeMap).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2-sự-khác-biệt-về-hiệu-năng-giữa-list"&gt;2. Sự khác biệt về hiệu năng giữa List&lt;/h2&gt;
&lt;p&gt;Việc chọn đúng loại List ảnh hưởng rất lớn đến tốc độ xử lý, đặc biệt với dữ liệu lớn.&lt;/p&gt;</description></item><item><title>Xử lý đa luồng và Concurrent Programming trong Java</title><link>http://localhost:1313/blog/java-threads/</link><pubDate>Fri, 26 Dec 2025 19:20:00 +0700</pubDate><guid>http://localhost:1313/blog/java-threads/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-threads.png" alt="Luồng trong java"&gt;&lt;/p&gt;
&lt;h2 id="1-thread-là-gì"&gt;1. Thread là gì?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Thread (Luồng)&lt;/strong&gt; là đơn vị nhỏ nhất của quá trình thực thi trong một ứng dụng. Một chương trình Java có thể chứa nhiều thread chạy song song, chia sẻ cùng bộ nhớ Heap nhưng có Stack riêng biệt.&lt;/p&gt;
&lt;p&gt;Đa luồng giúp ứng dụng phản hồi nhanh hơn, tận dụng tối đa CPU đa nhân và xử lý song song các tác vụ nặng như I/O hay Database.&lt;/p&gt;</description></item><item><title>Java 8+ Features: Làm chủ Stream API và Lambda Expression</title><link>http://localhost:1313/blog/java-8-streams/</link><pubDate>Fri, 26 Dec 2025 21:15:00 +0700</pubDate><guid>http://localhost:1313/blog/java-8-streams/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/java-8-streams.png" alt="Java 8 Streams"&gt;&lt;/p&gt;
&lt;h2 id="1-kỷ-nguyên-lập-trình-hàm-functional-programming"&gt;1. Kỷ nguyên lập trình hàm (Functional Programming)&lt;/h2&gt;
&lt;p&gt;Java 8 đánh dấu một bước ngoặt lớn khi giới thiệu các khái niệm &lt;strong&gt;Functional Programming&lt;/strong&gt; như Lambda Expression, Functional Interface, và Stream API. Lập trình hàm giúp mã nguồn ngắn gọn, giảm bớt các trạng thái (state) dư thừa và dễ bảo trì hơn so với mô hình OOP thuần túy trước đây.&lt;/p&gt;
&lt;h3 id="11-lambda-expression"&gt;1.1 Lambda Expression&lt;/h3&gt;
&lt;p&gt;Lambda Expression cho phép bạn truyền &lt;strong&gt;hành vi (behavior)&lt;/strong&gt; như một tham số, giúp loại bỏ các lớp ẩn danh (anonymous classes) dài dòng.&lt;/p&gt;</description></item><item><title>JavaScript Event Loop – Hiểu đúng để làm chủ bất đồng bộ</title><link>http://localhost:1313/blog/js-event-loop/</link><pubDate>Fri, 26 Dec 2025 22:30:00 +0700</pubDate><guid>http://localhost:1313/blog/js-event-loop/</guid><description>&lt;p&gt;&lt;img src="http://localhost:1313/img/blog/js-event-loop.png" alt="Sự kiện vòng lặp trong Javascript"&gt;&lt;/p&gt;
&lt;h2 id="1-javascript-là-single-threaded-nhưng-không-hề-đơn-giản"&gt;1. JavaScript là Single-threaded, nhưng không hề đơn giản&lt;/h2&gt;
&lt;p&gt;JavaScript thường bị hiểu lầm là “chậm” vì chỉ chạy trên một luồng duy nhất. Thực tế, chính mô hình &lt;strong&gt;single-threaded&lt;/strong&gt; kết hợp với &lt;strong&gt;non-blocking I/O&lt;/strong&gt; đã giúp JavaScript trở thành nền tảng cốt lõi của web hiện đại.&lt;/p&gt;
&lt;p&gt;JavaScript chỉ có một &lt;strong&gt;Call Stack&lt;/strong&gt;, đồng nghĩa với việc tại một thời điểm, chỉ có một đoạn code được thực thi. Tuy nhiên, các tác vụ nặng như &lt;code&gt;setTimeout&lt;/code&gt;, HTTP request, hay File I/O sẽ được ủy quyền cho môi trường thực thi (Browser hoặc Node.js) xử lý.&lt;/p&gt;</description></item><item><title>Closure &amp; Prototype trong JavaScript – Nền tảng quyền lực nhưng dễ bị hiểu sai</title><link>http://localhost:1313/blog/js-closure-prototype/</link><pubDate>Fri, 26 Dec 2025 23:15:00 +0700</pubDate><guid>http://localhost:1313/blog/js-closure-prototype/</guid><description>&lt;h2 id="1-closure-là-gì"&gt;1. Closure là gì?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Closure&lt;/strong&gt; là khả năng của một hàm ghi nhớ và truy cập được các biến nằm ngoài phạm vi (scope) của nó, ngay cả khi hàm bên ngoài đã thực thi xong. Nói cách khác, một hàm luôn “đi kèm” với lexical scope nơi nó được khai báo.&lt;/p&gt;
&lt;h3 id="ví-dụ-cơ-bản"&gt;Ví dụ cơ bản:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;function&lt;/span&gt; &lt;span style="color:#1f2328"&gt;outer&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;let&lt;/span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt; &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#0550ae"&gt;0&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;return&lt;/span&gt; &lt;span style="color:#cf222e"&gt;function&lt;/span&gt; &lt;span style="color:#1f2328"&gt;inner&lt;/span&gt;&lt;span style="color:#1f2328"&gt;()&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt;&lt;span style="color:#0550ae"&gt;++&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#cf222e"&gt;return&lt;/span&gt; &lt;span style="color:#1f2328"&gt;count&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#1f2328"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;const&lt;/span&gt; &lt;span style="color:#1f2328"&gt;counter&lt;/span&gt; &lt;span style="color:#0550ae"&gt;=&lt;/span&gt; &lt;span style="color:#1f2328"&gt;outer&lt;/span&gt;&lt;span style="color:#1f2328"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;counter&lt;/span&gt;&lt;span style="color:#1f2328"&gt;());&lt;/span&gt; &lt;span style="color:#57606a"&gt;// 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mặc dù outer() đã chạy xong, biến count vẫn tồn tại trong bộ nhớ vì inner() đang giữ tham chiếu đến nó. Đây chính là sức mạnh của Closure.&lt;/p&gt;</description></item><item><title>Tối ưu hiệu năng Frontend – DOM, Virtual DOM và Event Delegation</title><link>http://localhost:1313/blog/js-dom-performance/</link><pubDate>Fri, 26 Dec 2025 23:45:00 +0700</pubDate><guid>http://localhost:1313/blog/js-dom-performance/</guid><description>&lt;h2 id="1-dom-là-gì-và-tại-sao-nó-chậm"&gt;1. DOM là gì và tại sao nó chậm?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DOM (Document Object Model)&lt;/strong&gt; là cấu trúc dạng cây đại diện cho toàn bộ HTML của trang web. Trình duyệt sử dụng DOM để render giao diện, gắn CSS và lắng nghe sự kiện.&lt;/p&gt;
&lt;p&gt;Rất nhiều website chậm không phải vì logic phức tạp, mà vì &lt;strong&gt;thao tác với DOM sai cách&lt;/strong&gt;. Mỗi khi DOM thay đổi, trình duyệt phải thực hiện chuỗi tác vụ tốn kém:&lt;/p&gt;</description></item><item><title>Module Bundler, NPM và ES Modules – Nền tảng hệ sinh thái JavaScript hiện đại</title><link>http://localhost:1313/blog/js-modern-tooling/</link><pubDate>Fri, 26 Dec 2025 23:55:00 +0700</pubDate><guid>http://localhost:1313/blog/js-modern-tooling/</guid><description>&lt;h2 id="1-tại-sao-cần-module-bundler"&gt;1. Tại sao cần Module Bundler?&lt;/h2&gt;
&lt;p&gt;Trong các dự án nhỏ, ta có thể nhúng trực tiếp nhiều thẻ &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. Tuy nhiên, khi dự án lớn dần, cách làm này bộc lộ nhiều nhược điểm: khó quản lý thứ tự load, dễ trùng biến global, tốn nhiều HTTP requests và khó tối ưu hiệu năng.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Module Bundler&lt;/strong&gt; (Webpack, Vite, Rollup&amp;hellip;) ra đời để:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Phân tích đồ thị phụ thuộc (&lt;strong&gt;Dependency Graph&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Gộp nhiều file thành một hoặc vài gói (&lt;strong&gt;Bundle&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;Loại bỏ code thừa (&lt;strong&gt;Tree Shaking&lt;/strong&gt;) và nén code (&lt;strong&gt;Minify&lt;/strong&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ví-dụ-đơn-giản"&gt;Ví dụ đơn giản:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-javascript" data-lang="javascript"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// math.js
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;export&lt;/span&gt; &lt;span style="color:#cf222e"&gt;function&lt;/span&gt; &lt;span style="color:#1f2328"&gt;add&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;a&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#1f2328"&gt;b&lt;/span&gt;&lt;span style="color:#1f2328"&gt;)&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt; &lt;span style="color:#cf222e"&gt;return&lt;/span&gt; &lt;span style="color:#1f2328"&gt;a&lt;/span&gt; &lt;span style="color:#0550ae"&gt;+&lt;/span&gt; &lt;span style="color:#1f2328"&gt;b&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt; &lt;span style="color:#1f2328"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#57606a"&gt;// app.js
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#cf222e"&gt;import&lt;/span&gt; &lt;span style="color:#1f2328"&gt;{&lt;/span&gt; &lt;span style="color:#1f2328"&gt;add&lt;/span&gt; &lt;span style="color:#1f2328"&gt;}&lt;/span&gt; &lt;span style="color:#1f2328"&gt;from&lt;/span&gt; &lt;span style="color:#0a3069"&gt;&amp;#34;./math.js&amp;#34;&lt;/span&gt;&lt;span style="color:#1f2328"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;console&lt;/span&gt;&lt;span style="color:#1f2328"&gt;.&lt;/span&gt;&lt;span style="color:#1f2328"&gt;log&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#1f2328"&gt;add&lt;/span&gt;&lt;span style="color:#1f2328"&gt;(&lt;/span&gt;&lt;span style="color:#0550ae"&gt;2&lt;/span&gt;&lt;span style="color:#1f2328"&gt;,&lt;/span&gt; &lt;span style="color:#0550ae"&gt;3&lt;/span&gt;&lt;span style="color:#1f2328"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Bundler sẽ gom lại thành một file duy nhất được tối ưu:&lt;/p&gt;</description></item></channel></rss>